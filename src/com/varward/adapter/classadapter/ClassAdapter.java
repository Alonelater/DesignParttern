package com.varward.adapter.classadapter;
/**
 *
 * 今天我们讲述适配器模式  什么是适配器模式
 *
 *适配器模式
 * 适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。
 *
 * 在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。
 *
 * 根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。
 *
 * 角色
 * Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。
 *
 * Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。
 *
 * Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。
 *
 *
 * 举个简单的例子 加入我们去意大利旅游 由于国内的电压和国外的电压，还有安装在墙内的插板的孔是完全不一致的
 * 那这时候我们既不想买过意大利牌子的专属充电器 又想把我们的设备充上电怎么办 那我们就会去酒店前台跟工作人员要一个转接头去用于适配我们自己带来的充电器插口的问题
 * 这就是适配器模式的使用场景 适配器模式总共有三种方式
 * 1.对象适配器
 *
 */
public class ClassAdapter  extends Voltage200V implements IVoltage5V {
//    @Override
//    public int outPut200V() {
//        System.out.println("这是子类重写后的方法");
//        return 24;
//    }


    //首先我们继承了Voltage200V  所以我们可以获得意大利的电压  只要子类没有重写父类的方法 那么调用的就是父类的方法

    @Override
    public int change() {
        //定义国内电压
        int temp ;
        //获得200V的电压
        int i = outPut200V();
         temp = i+20;
         //经过转化
        int dest = temp/44;
        System.out.println("手机充电电压转换完成");
        return  dest;
    }
}
